---
title: "Preprocessing of FCS files - before clustering"
author: "Anne-Maud Ferreira"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette: 
    toc: true
vignette: >
  %\VignetteIndexEntry{clustering}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width=8, 
  fig.height=5
)
```

```{r setup, warning = FALSE, message = FALSE}
library(CyTOFtoolbox)
library(flowCore)
library(CATALYST)
library(SingleCellExperiment)
```

# Metadata

## Markers information

```{r read_markers_info}
# Path
path_markers <- system.file("extdata", "markers_info.txt", package = "CyTOFtoolbox")
# Read file
markers_info <- read.table(path_markers)
# Check
## Column names
colnames(markers_info)
## Marker class
unique(markers_info$marker_class)
```

## Samples information

```{r read_samples_info}
# Path
path_samples <- system.file("extdata", "samples_info.txt", package = "CyTOFtoolbox")
# Read file
samples_info <- read.table(path_samples, as.is = "filename")
## NB: File name must be a character string and not a factor
# Check
## Column names
colnames(samples_info)
```

# Read FCS files

```{r read_fcsfiles}
# Path
path_data <- system.file("extdata", package = "CyTOFtoolbox")
# Read files as a flowSet
flowSet_aghaeepour_sub_data <- read.flowSet(files = samples_info$filename,
                                    path = path_data)
```

## Check file names

```{r check_file_names}
# File names
flowSet_aghaeepour_sub_data_filename <- keyword(flowSet_aghaeepour_sub_data, "FILENAME")
if (all(flowSet_aghaeepour_sub_data_filename == paste0(path_data, "/", samples_info$filename))) {
  keyword(flowSet_aghaeepour_sub_data) <- list("FILENAME" = samples_info$filename)
} else {
  error("File names of the flowset not corresponding to the file names of the metadata. Please check.")
}
```

## Check markers list

```{r check_marker_list}
if (!all(colnames(flowSet_aghaeepour_sub_data) %in%
         as.character(markers_info$fcs_colname))) {
  warning("Marker names of the flowset not corresponding to the marker file names of the metadata. Please check.")
}
# Complete the marker list
# Get the name of the markers who are missing in the markers metadata
all_markers <- colnames(flowSet_aghaeepour_sub_data) %in%
                  markers_info$fcs_colname
missing_markers <- subset(colnames(flowSet_aghaeepour_sub_data),
                                      !all_markers)
# Create a data.frame of the missing markers
df_missing_markers <- data.frame("fcs_colname" = missing_markers,
                                 "antigen" = missing_markers,
                                 "marker_class" = "none")
# Add the missing markers to the metadata
markers_info_withmissingmarkers <- rbind(df_missing_markers, markers_info)
```

# Prepare the data

```{r prepare_data}
## Prepare the data
aghaeepour_sub_data <- CATALYST::prepData(flowSet_aghaeepour_sub_data,
                                  panel = markers_info,
                                  md = samples_info,
                                  md_cols = list(file = "filename",
                                                 id = "filename",
                                                 factors = c("patient_id", "condition")),
                                  cofactor = 5) # automatically applied arcsinh transformation with cofactor = 5

```

# Analysis 

## Clustering analysis 

To perform the clustering, we need to specify the type markers on which the clustering
will be performed.

```{r clustering}
# Specify markers to use for clustering
type_markers(aghaeepour_sub_data)
# Cluster
aghaeepour_sub_data <- cluster(aghaeepour_sub_data, 
                           features = type_markers(aghaeepour_sub_data),
                           xdim = 10, ydim = 10, maxK = 20, 
                           verbose = FALSE, seed = 1234)
```

Based on the delta area plot which represent the stability gained when using
$k$ clusters, we can determine the *optimal* number of cluster:

```{r delta_aera_plot}
# Print the delta area plot
metadata(aghaeepour_sub_data)$delta_area
```

## Dimensionality reduction with UMAP

Dimension reduction is computed with UMAP.

```{r UMAP}
# Extract data from sce object
umap_aghaeepour_input_data <- t(assay(aghaeepour_sub_data))
# UMAP dimensionality reduction
set.seed(1234)
dr_umap_aghaeepour <- uwot::umap(umap_aghaeepour_input_data, n_neighbors = 20, min_dist = 0.1)
# Add the dimensionality reduction to the SCE
colnames(dr_umap_aghaeepour) <- c("X1", "X2")
reducedDims(aghaeepour_sub_data) <- list("UMAP" = dr_umap_aghaeepour)
```

### Visualization of the clusters on the UMAP space

The `plot_metacluster` function allows the visualization of the metaclusters in
the dimensional reduction space (as UMAP). It is a `ggplot2` object.

```{r plot_cluster, eval = TRUE}
# Extract SCE information before plotting
aghaeepour_expinfo_dr_metacluster_values <- extract_SCE_info(sce = aghaeepour_sub_data,
                                                              metacluster = "meta6")

# Plot
plot_metaclusters(df = aghaeepour_expinfo_dr_metacluster_values, 
                  metacluster = "meta6")
```

To save the plot as a png image (in case the dataset contains too many points and cannot be saved as a PDF), the following code can be used and adpated:

```{r cluster_savepng, eval = FALSE}
# Do not run
png(file = "PNG_clusters_meta6_aghaeepour.png", width = 4000, height = 3800, unit = "px")
ggplot(aghaeepour_expinfo_dr_metacluster_values, aes_string(x = names_dr[1], y = names_dr[2])) +
  geom_point(aes(col = meta6), size = 2, alpha = 0.1, pch = 16) +
  scale_color_manual(values = catalyst_col, name = "6 meta-clusters") +
  labs(x = paste(dr, "1"), y = paste(dr, "2")) + 
  theme_bw() + 
  guides(colour = guide_legend(override.aes = list(size = 30, alpha = 1))) +
  theme(axis.text = element_text(size = 70), axis.title = element_text(size = 80), 
        legend.title = element_text(size = 80), legend.text = element_text(size = 70),
        axis.ticks.length= unit(0.8, "cm"), axis.ticks = element_line(size = 2),
        panel.border = element_rect(size = 2), panel.grid.major = element_blank()) 
dev.off()
```

## Differential Abundance (DA) tests

These tests from the `diffcyt` package perform differential abundance tests
within each cell population, i.e. clusters.

The default method recommended by the package use `edgeR`, which fits a negative 
binomial generalized log linear model for each cluster and then performs likelihood 
ratio tests:

```{r DA_tests_edgeR}
# Create design & constrast matrix
design_matrix_aghaeepour <- createDesignMatrix(ei(aghaeepour_sub_data), 
                                                cols_design = "condition")
contrast_aghaeepour <- createContrast(c(0, 1))
# Test with edgeR
## Default method recommended by the package
res_DA_aghaeepour_edgeR <- diffcyt(aghaeepour_sub_data, 
                              clustering_to_use = "meta6",
                              analysis_type = "DA", 
                              method_DA = "diffcyt-DA-edgeR",
                              design = design_matrix_aghaeepour, 
                              contrast = contrast_aghaeepour)
```

There is a non-parametric test available with `voom`. The `voom` method transforms 
the raw cluster cell counts and estimate observation-level precision weights in order 
to stabilize the meanâ€“variance relationship. Then, one Linear Model is fitted for each cluster.

```{r DA_tests_voom, results = 'hide', fig.show = 'hide'}
# Design & constrast matrix are the same as for the diffcyt-DA-edgeR test
## design_matrix_aghaeepour <- createDesignMatrix(ei(aghaeepour_sub_data), 
##                                                cols_design = "condition")
## contrast_aghaeepour <- createContrast(c(0, 1))
# Test with voom
## Non-parametric test
res_DA_aghaeepour_voom <- diffcyt(aghaeepour_sub_data, 
                              clustering_to_use = "meta6",
                              analysis_type = "DA", 
                              method_DA = "diffcyt-DA-voom",
                              design = design_matrix_aghaeepour, 
                              contrast = contrast_aghaeepour, 
                              plot = FALSE)
```

Additional notes for the analysis:

- With this dataset, the comparison is straightforward. However in case you need 
to filter for the comparison, the `filterSCE()` (from the `CATALYST` package)
function can be used.
- Factors in the metadata crashed the analysis

### Visualization - DA test heatmap

The `plotDiffHeatmap` function plots the results of the DA tests.
The heatmap represents the proportion of each metacluster in each sample. These 
proportions are first scaled with arcsine-square-root transformation and then z-score 
normalized in each cluster. The cluster ID is labeled along the left side of the heatmap, 
ordered by significance, which is shown along the right side of the heatmap. 
The differential abundance test reports adjusted p-values (FDR).


The `plotDAheatmap` modified this function to get colors more different for the samples
and conditions. The heat color scale goes from grey to red, with grey showing under-representation
and red showing over-representation. 

Additionally, there is the possibility to hide the sample IDs with 
the `show_sample_ID` parameter (by default `show_sample_ID = TRUE`).

- `diffcyt-DA-edgeR`:

```{r DA_test_heatmap_edgeR, message=FALSE, warning=FALSE}
# Heatmap of the DA test results
## median (arcsinh-transformed) cell-type marker expressions (across all samples)
## relative cluster abundances by samples
plotDAheatmap(x = aghaeepour_sub_data,
              y = res_DA_aghaeepour_edgeR, 
              comparison = "condition",
              all = TRUE)
```

- `diffcyt-DA-voom`:

```{r DA_test_heatmap_voom, message=FALSE, warning=FALSE}
# Heatmap of the DA test results
## median (arcsinh-transformed) cell-type marker expressions (across all samples)
## relative cluster abundances by samples
plotDAheatmap(x = aghaeepour_sub_data,
              y = res_DA_aghaeepour_voom, 
              comparison = "condition",
              all = TRUE)
```

Note: The colors of the top of the heatmap are randomly selected. However the 
function `colors_DAheatmap` allows to generate colors which can be given as
an input parameter in the `plotDAheatmap` function.

```{r colors_DAheatmap_example, message=FALSE, warning=FALSE}
# Define the colors which will be used for the heatmaps
# Keeps only the columns which will be displayed on the top part of the heatmap
df_levels <- as.data.frame(colData(aghaeepour_sub_data)) %>% 
   dplyr::select(-cluster_id, -sample_id) %>% 
   unique()
# Order the values based on the comparison we want to test
df_levels <- data.frame(df_levels[order(df_levels[,"condition"]),], row.names = NULL)
# Generate the colors
colors_aghaeepour <- colors_DAheatmap(exp_info = df_levels, "condition")
colors_aghaeepour

# Use these colors in the heatmap
plotDAheatmap(x = aghaeepour_sub_data,
              y = res_DA_aghaeepour_voom, 
              comparison = "condition",
              all = TRUE,
              predefined_colors = colors_aghaeepour) # Add colors as an input parameter
```
