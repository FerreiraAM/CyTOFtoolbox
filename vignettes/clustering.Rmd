---
title: "Clustering"
author: "Anne-Maud Ferreira"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette: 
    toc: true
vignette: >
  %\VignetteIndexEntry{clustering}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width=8, 
  fig.height=5
)
```

```{r setup, warning = FALSE, message = FALSE}
library(CyTOFtoolbox)
library(CATALYST)
library(diffcyt)
library(uwot)
library(SingleCellExperiment)
library(ggplot2)
library(dplyr)
```

# Introduction

This vignette retakes the 
[workflow of CATALYST](https://bioconductor.org/packages/release/bioc/vignettes/CATALYST/inst/doc/differential_analysis.html) 
for the clustering. The clustering is performed using a combination of two 
algorithms: `FlowSOM` clustering and `ConsensusClusterPlus` meta clustering.

The vignette proposes functions to modify the results visualizations:

- UMAP;
- Differential Abudance (DA) heatmaps.

# Data preprocessing

## Data 

We use the same data as proposed in the `CATALYST` workflow and prepare the data.

The dataset is the `Bodenmiller_BCR_XL` dataset originally from Bodenmiller et al. (2012).

```{r load_data, warning = FALSE, message = FALSE}
# Load data
data(PBMC_fs, PBMC_panel, PBMC_md)
# Prepare data
sce_Bodenmiller <- prepData(PBMC_fs, PBMC_panel, PBMC_md)
```

# Analysis 

## Clustering analysis 

To perform the clustering, we need to specify the type markers on which the clustering
will be performed.

```{r clustering}
# Specify markers to use for clustering
type_markers(sce_Bodenmiller)
# Cluster
sce_Bodenmiller <- cluster(sce_Bodenmiller, 
                           features = type_markers(sce_Bodenmiller),
                           xdim = 10, ydim = 10, maxK = 20, 
                           verbose = FALSE, seed = 1234)
```

Based on the delta area plot which represent the stability gained when using
$k$ clusters, we can determine the *optimal* number of cluster:

```{r delta_aera_plot}
# Print the delta area plot
metadata(sce_Bodenmiller)$delta_area
```

## Dimensionality reduction with UMAP

Dimension reduction is computed with UMAP.

```{r UMAP}
# Extract data from sce object
umap_Bodenmiller_input_data <- t(assay(sce_Bodenmiller))
# UMAP dimensionality reduction
set.seed(1234)
dr_umap_Bodenmiller <- uwot::umap(umap_Bodenmiller_input_data, n_neighbors = 20, min_dist = 0.1)
# Add the dimensionality reduction to the SCE
colnames(dr_umap_Bodenmiller) <- c("X1", "X2")
reducedDims(sce_Bodenmiller) <- list("UMAP" = dr_umap_Bodenmiller)
```

### Visualization of the clusters on the UMAP space

The `plot_metacluster` function allows the visualization of the metaclusters in
the dimensional reduction space (as UMAP). It is a `ggplot2` object.

```{r plot_cluster, eval = TRUE}
# Extract SCE information before plotting
Bodenmiller_expinfo_dr_metacluster_values <- extract_SCE_info(sce = sce_Bodenmiller,
                                                              metacluster = "meta8")

# Plot
plot_metaclusters(df = Bodenmiller_expinfo_dr_metacluster_values, 
                  metacluster = "meta8")
```

To save the plot as a png image (in case the dataset contains too many points and cannot be saved as a PDF), the following code can be used and adpated:

```{r cluster_savepng, eval = FALSE}
# Do not run
png(file = "PNG_clusters_meta8_Bodenmiller.png", width = 4000, height = 3800, unit = "px")
ggplot(Bodenmiller_expinfo_dr_metacluster_values, aes_string(x = names_dr[1], y = names_dr[2])) +
  geom_point(aes(col = meta8), size = 2, alpha = 0.1, pch = 16) +
  scale_color_manual(values = catalyst_col, name = "8 meta-clusters") +
  labs(x = paste(dr, "1"), y = paste(dr, "2")) + 
  theme_bw() + 
  guides(colour = guide_legend(override.aes = list(size = 30, alpha = 1))) +
  theme(axis.text = element_text(size = 70), axis.title = element_text(size = 80), 
        legend.title = element_text(size = 80), legend.text = element_text(size = 70),
        axis.ticks.length= unit(0.8, "cm"), axis.ticks = element_line(size = 2),
        panel.border = element_rect(size = 2), panel.grid.major = element_blank()) 
dev.off()
```

## Differential Abundance (DA) tests

These tests from the `diffcyt` package perform differential abundance tests
within each cell population, i.e. clusters.

The default method recommended by the package use `edgeR`, which fits a negative 
binomial generalized log linear model for each cluster and then performs likelihood 
ratio tests:

```{r DA_tests_edgeR}
# Create design & constrast matrix
design_matrix_Bodenmiller <- createDesignMatrix(ei(sce_Bodenmiller), 
                                                cols_design = "condition")
contrast_Bodenmiller <- createContrast(c(0, 1))
# Test with edgeR
## Default method recommended by the package
res_DA_Bodenmiller_edgeR <- diffcyt(sce_Bodenmiller, 
                              clustering_to_use = "meta8",
                              analysis_type = "DA", 
                              method_DA = "diffcyt-DA-edgeR",
                              design = design_matrix_Bodenmiller, 
                              contrast = contrast_Bodenmiller)
```

There is a non-parametric test available with `voom`. The `voom` method transforms 
the raw cluster cell counts and estimate observation-level precision weights in order 
to stabilize the meanâ€“variance relationship. Then, one Linear Model is fitted for each cluster.

```{r DA_tests_voom, results = 'hide', fig.show = 'hide'}
# Design & constrast matrix are the same as for the diffcyt-DA-edgeR test
## design_matrix_Bodenmiller <- createDesignMatrix(ei(sce_Bodenmiller), 
##                                                cols_design = "condition")
## contrast_Bodenmiller <- createContrast(c(0, 1))
# Test with voom
## Non-parametric test
res_DA_Bodenmiller_voom <- diffcyt(sce_Bodenmiller, 
                              clustering_to_use = "meta8",
                              analysis_type = "DA", 
                              method_DA = "diffcyt-DA-voom",
                              design = design_matrix_Bodenmiller, 
                              contrast = contrast_Bodenmiller, 
                              plot = FALSE)
```

Additional notes for the analysis:

- With this dataset, the comparison is straightforward. However in case you need 
to filter for the comparison, the `filterSCE()` (from the `CATALYST` package)
function can be used.
- Factors in the metadata crashed the analysis

### Visualization - DA test heatmap

The `plotDiffHeatmap` function plots the results of the DA tests.
The heatmap represents the proportion of each metacluster in each sample. These 
proportions are first scaled with arcsine-square-root transformation and then z-score 
normalized in each cluster. The cluster ID is labeled along the left side of the heatmap, 
ordered by significance, which is shown along the right side of the heatmap. 
The differential abundance test reports adjusted p-values (FDR).


The `plotDAheatmap` modified this function to get colors more different for the samples
and conditions. The heat color scale goes from grey to red, with grey showing under-representation
and red showing over-representation. 

Additionally, there is the possibility to hide the sample IDs with 
the `show_sample_ID` parameter (by default `show_sample_ID = TRUE`).

- `diffcyt-DA-edgeR`:

```{r DA_test_heatmap_edgeR, message=FALSE, warning=FALSE}
# Heatmap of the DA test results
## median (arcsinh-transformed) cell-type marker expressions (across all samples)
## relative cluster abundances by samples
plotDAheatmap(x = sce_Bodenmiller,
              y = res_DA_Bodenmiller_edgeR, 
              comparison = "condition",
              all = TRUE)
```

- `diffcyt-DA-voom`:

```{r DA_test_heatmap_voom, message=FALSE, warning=FALSE}
# Heatmap of the DA test results
## median (arcsinh-transformed) cell-type marker expressions (across all samples)
## relative cluster abundances by samples
plotDAheatmap(x = sce_Bodenmiller,
              y = res_DA_Bodenmiller_voom, 
              comparison = "condition",
              all = TRUE)
```

Note: The colors of the top of the heatmap are randomly selected. However the 
function `colors_DAheatmap` allows to generate colors which can be given as
an input parameter in the `plotDAheatmap` function.

```{r colors_DAheatmap_example, message=FALSE, warning=FALSE}
# Define the colors which will be used for the heatmaps
# Keeps only the columns which will be displayed on the top part of the heatmap
df_levels <- as.data.frame(colData(sce_Bodenmiller)) %>% 
   dplyr::select(-cluster_id, -sample_id) %>% 
   unique()
# Order the values based on the comparison we want to test
df_levels <- data.frame(df_levels[order(df_levels[,"condition"]),], row.names = NULL)
# Generate the colors
colors_Bodenmiller <- colors_DAheatmap(exp_info = df_levels, "condition")
colors_Bodenmiller

# Use these colors in the heatmap
plotDAheatmap(x = sce_Bodenmiller,
              y = res_DA_Bodenmiller_voom, 
              comparison = "condition",
              all = TRUE,
              predefined_colors = colors_Bodenmiller) # Add colors as an input parameter
```

 
